.TH "libcmd_line_parser" 3 "Sat Sep 14 2024" "Version 0.9.2.0" "argparse" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libcmd_line_parser \- Command line argument parsing utilities
.SH SYNOPSIS
.br
.PP
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBcmd_line_parse\&.h\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct argData * \fBargHandle\fP"
.br
.RI "Argument data structure pointer abstraction\&. "
.ti -1c
.RI "typedef struct cmdLineParser * \fBcmdLineParserHandle\fP"
.br
.RI "Command line parser structure pointer abstraction\&. "
.ti -1c
.RI "typedef char const  * \fBparsercstr\fP"
.br
.RI "Parser 'C' string abstraction\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBargHandle\fP \fBcreateShortIntParserArg\fP (short int *arg)"
.br
.RI "Create a short int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateIntParserArg\fP (int *arg)"
.br
.RI "Create a int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLongIntParserArg\fP (long int *arg)"
.br
.RI "Create a long int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLLongIntParserArg\fP (long long int *arg)"
.br
.RI "Create a long long int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateShortUIntParserArg\fP (short unsigned *arg)"
.br
.RI "Create a short unsigned int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateUIntParserArg\fP (unsigned *arg)"
.br
.RI "Create an unsigned int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLongUIntParserArg\fP (long unsigned *arg)"
.br
.RI "Create a long unsigned int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLLongUIntParserArg\fP (long long unsigned *arg)"
.br
.RI "Create a long long unsigned int parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateFloatParserArg\fP (double *arg)"
.br
.RI "Create a double parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateCharParserArg\fP (char *arg)"
.br
.RI "Create a single character parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateStringParserArg\fP (char *arg, int elementCount)"
.br
.RI "Create a string parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateParserFlagArg\fP (bool defaultValue, bool setValue, bool *flag)"
.br
.RI "Create a parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateIncrementingFlagArg\fP (int *flag)"
.br
.RI "Create a incrementing parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateShortIntArrayParserArg\fP (short int arg[], int elementCount)"
.br
.RI "Create a short integer array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateIntArrayParserArg\fP (int arg[], int elementCount)"
.br
.RI "Create a integer array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLongIntArrayParserArg\fP (long int arg[], int elementCount)"
.br
.RI "Create a long integer array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLLongIntArrayParserArg\fP (long long int arg[], int elementCount)"
.br
.RI "Create a long long integer array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateShortUIntArrayParserArg\fP (short unsigned arg[], int elementCount)"
.br
.RI "Create an short unsigned array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateUIntArrayParserArg\fP (unsigned arg[], int elementCount)"
.br
.RI "Create an unsigned array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLongUIntArrayParserArg\fP (long unsigned arg[], int elementCount)"
.br
.RI "Create an long unsigned array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateLLongUIntArrayParserArg\fP (long long unsigned arg[], int elementCount)"
.br
.RI "Create an long long unsigned array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateDoubleArrayParserArg\fP (double arg[], int elementCount)"
.br
.RI "Create a double array parser argument object\&. "
.ti -1c
.RI "\fBargHandle\fP \fBcreateStringArrayParserArg\fP (char **arg, int elementCount)"
.br
.RI "Create a double array parser argument object\&. "
.ti -1c
.RI "void \fBreleaseParserArg\fP (\fBargHandle\fP arg)"
.br
.RI "Release the parser argument handle\&. "
.ti -1c
.RI "\fBcmdLineParserHandle\fP \fBgetParser\fP (const \fBparsercstr\fP usage, const \fBparsercstr\fP description, bool abortOnError, bool disableDefaultHelp, int debugLevel)"
.br
.RI "Get the Parser object\&. "
.ti -1c
.RI "void \fBreleaseParser\fP (\fBcmdLineParserHandle\fP parser, bool releaseArgHandles)"
.br
.RI "Release the parser instance\&. "
.ti -1c
.RI "void \fBsetEpilog\fP (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP epilog)"
.br
.RI "Set the Epilog text\&. "
.ti -1c
.RI "void \fBsetProgramName\fP (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP progName)"
.br
.RI "Set the Program Name for the usage string\&. "
.ti -1c
.RI "void \fBsetKeyPrefix\fP (\fBcmdLineParserHandle\fP parser, \fBparsercstr\fP prefix)"
.br
.RI "Set the argument key prefix value\&. "
.ti -1c
.RI "void \fBdisableDefaultHelpArgument\fP (\fBcmdLineParserHandle\fP parser)"
.br
.RI "Disable the default help argument setup\&. "
.ti -1c
.RI "void \fBdisableHelpDisplayOnError\fP (\fBcmdLineParserHandle\fP parser)"
.br
.RI "Disable the help display on parsing error\&. "
.ti -1c
.RI "void \fBdisableSingleCharListArgument\fP (\fBcmdLineParserHandle\fP parser)"
.br
.RI "Disable the single character list input argument parsing\&. "
.ti -1c
.RI "void \fBenableUnknowArgumentIgnore\fP (\fBcmdLineParserHandle\fP parser)"
.br
.RI "Enable flag to ignore unknown arguments, default is to generate an error if an unknown argument is found\&. "
.ti -1c
.RI "void \fBaddKeyArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"
.br
.RI "Add a new key based command line argument to the argument list\&. "
.ti -1c
.RI "void \fBaddKeyArrayArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const int nargs, const bool required)"
.br
.RI "Add a new key based command line array argument to the argument list\&. "
.ti -1c
.RI "void \fBaddFlagArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"
.br
.RI "Add a new key based flag command line argument to the argument list\&. "
.ti -1c
.RI "void \fBaddIncrementingArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"
.br
.RI "Add a new key based incrementing command line argument to the argument list\&. "
.ti -1c
.RI "void \fBaddPositionalArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP helpText, const bool required)"
.br
.RI "Add a new positinal based command line argument to the argument list\&. "
.ti -1c
.RI "void \fBaddPositionalArrayArgument\fP (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP helpText, const int nargs, const bool required)"
.br
.RI "Add a new positinal based command line array argument to the argument list\&. "
.ti -1c
.RI "void \fBsetPositionalNameStop\fP (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP positionalArgumentName)"
.br
.RI "Set the name of the positional argument to stop parsing\&. "
.ti -1c
.RI "int \fBparse\fP (\fBcmdLineParserHandle\fP parser, int argc, char *argv[], int startingArgIndex, int endingArgIndex)"
.br
.RI "Parse the input command line arguments\&. "
.ti -1c
.RI "void \fBdisplayHelp\fP (\fBcmdLineParserHandle\fP parser)"
.br
.RI "Print the formatted help message to the input stream\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SH "Function Documentation"
.PP 
.SS "void addFlagArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"

.PP
Add a new key based flag command line argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIargKeys\fP - Delimieted list of argument key values 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "void addIncrementingArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"

.PP
Add a new key based incrementing command line argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIargKeys\fP - Delimieted list of argument key values 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "void addKeyArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const bool required)"

.PP
Add a new key based command line argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIargKeys\fP - Delimieted list of argument key values 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "void addKeyArrayArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP argKeys, const \fBparsercstr\fP helpText, const int nargs, const bool required)"

.PP
Add a new key based command line array argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIargKeys\fP - Delimieted list of argument key values 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fInargs\fP - Number of argument values that follow 0 : Argument is a flag with no following values 1 : Simple argument with a single value N : ARRAY argument with exactly N arguments, if less than N arguments are found it is flagged as an error -N : ARRAY argument with up to N arguments, if more than N arguments are found it is flagged as an error 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "void addPositionalArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP helpText, const bool required)"

.PP
Add a new positinal based command line argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "void addPositionalArrayArgument (\fBcmdLineParserHandle\fP parser, const \fBargHandle\fP arg, const \fBparsercstr\fP name, const \fBparsercstr\fP helpText, const int nargs, const bool required)"

.PP
Add a new positinal based command line array argument to the argument list\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIarg\fP - Handle of the argument to add 
.br
\fIname\fP - Human name used in the help messages 
.br
\fIhelpText\fP - Help text to be printed in the help message 
.br
\fInargs\fP - Number of argument values that follow 0 : Argument is a flag with no following values 1 : Simple argument with a single value N : ARRAY argument with exactly N arguments, if less than N arguments are found it is flagged as an error -N : ARRAY argument with up to N arguments, if more than N arguments are found it is flagged as an error 
.br
\fIrequired\fP - True if argument is required, false if arguemnt is optional 
.RE
.PP

.SS "\fBargHandle\fP createCharParserArg (char * arg)"

.PP
Create a single character parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the character argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createDoubleArrayParserArg (double arg[], int elementCount)"

.PP
Create a double array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createFloatParserArg (double * arg)"

.PP
Create a double parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createIncrementingFlagArg (int * flag)"

.PP
Create a incrementing parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIflag\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createIntArrayParserArg (int arg[], int elementCount)"

.PP
Create a integer array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createIntParserArg (int * arg)"

.PP
Create a int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLLongIntArrayParserArg (long long int arg[], int elementCount)"

.PP
Create a long long integer array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the long long integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLLongIntParserArg (long long int * arg)"

.PP
Create a long long int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLLongUIntArrayParserArg (long long unsigned arg[], int elementCount)"

.PP
Create an long long unsigned array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the long long unsigned integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLLongUIntParserArg (long long unsigned * arg)"

.PP
Create a long long unsigned int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLongIntArrayParserArg (long int arg[], int elementCount)"

.PP
Create a long integer array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the long integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLongIntParserArg (long int * arg)"

.PP
Create a long int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLongUIntArrayParserArg (long unsigned arg[], int elementCount)"

.PP
Create an long unsigned array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the long unsigned integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createLongUIntParserArg (long unsigned * arg)"

.PP
Create a long unsigned int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createParserFlagArg (bool defaultValue, bool setValue, bool * flag)"

.PP
Create a parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIdefaultValue\fP - Initial value 
.br
\fIsetValue\fP - Value if flag variable was found 
.br
\fIflag\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createShortIntArrayParserArg (short int arg[], int elementCount)"

.PP
Create a short integer array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the short integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createShortIntParserArg (short int * arg)"

.PP
Create a short int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createShortUIntArrayParserArg (short unsigned arg[], int elementCount)"

.PP
Create an short unsigned array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the short unsigned integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createShortUIntParserArg (short unsigned * arg)"

.PP
Create a short unsigned int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createStringArrayParserArg (char ** arg, int elementCount)"

.PP
Create a double array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the constant character pointer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createStringParserArg (char * arg, int elementCount)"

.PP
Create a string parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the string argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createUIntArrayParserArg (unsigned arg[], int elementCount)"

.PP
Create an unsigned array parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the unsigned integer array argument storage 
.br
\fIelementCount\fP - Size of the array in elements
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "\fBargHandle\fP createUIntParserArg (unsigned * arg)"

.PP
Create an unsigned int parser argument object\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Pointer to the argument storage
.RE
.PP
\fBReturns\fP
.RS 4
argHandle - Handle to use when adding the argument to the parser argument list 
.RE
.PP

.SS "void disableHelpDisplayOnError (\fBcmdLineParserHandle\fP parser)"

.PP
Disable the help display on parsing error\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.RE
.PP

.SS "void disableSingleCharListArgument (\fBcmdLineParserHandle\fP parser)"

.PP
Disable the single character list input argument parsing\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.RE
.PP

.SS "void displayHelp (\fBcmdLineParserHandle\fP parser)"

.PP
Print the formatted help message to the input stream\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.RE
.PP

.SS "void enableUnknowArgumentIgnore (\fBcmdLineParserHandle\fP parser)"

.PP
Enable flag to ignore unknown arguments, default is to generate an error if an unknown argument is found\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.RE
.PP

.SS "\fBcmdLineParserHandle\fP getParser (const \fBparsercstr\fP usage, const \fBparsercstr\fP description, bool abortOnError, bool disableDefaultHelp, int debugLevel)"

.PP
Get the Parser object\&. 
.PP
\fBParameters\fP
.RS 4
\fIusage\fP - Usage sting for help display 
.br
\fIdescription\fP - Description of tool for the help display 
.br
\fIabortOnError\fP - True = abort parsing on the first error, False = continue parsing to the end 
.br
\fIdisableDefaultHelp\fP - True = display the help mesage if a parsing error occurs, False = do not display the help message until parserDisplayHelp() is called 
.br
\fIdebugLevel\fP - Debug output verbosity level, 0 = none, 5 = full
.RE
.PP
\fBReturns\fP
.RS 4
cmdLineParserHandle - Handle to the created argument parser 
.RE
.PP

.SS "int parse (\fBcmdLineParserHandle\fP parser, int argc, char * argv[], int startingArgIndex, int endingArgIndex)"

.PP
Parse the input command line arguments\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIargc\fP - Number of char pointers in the argv[] array 
.br
\fIargv\fP - Array of command line text entries 
.br
\fIstartingArgIndex\fP - argv index to start parsing arguments 
.br
\fIendingArgIndex\fP - argv index to stop parsing arguments, -1 == argc
.RE
.PP
\fBReturns\fP
.RS 4
int - Index of the last argument parsed or -1 if an error occured 
.RE
.PP

.SS "void releaseParser (\fBcmdLineParserHandle\fP parser, bool releaseArgHandles)"

.PP
Release the parser instance\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIreleaseArgHandles\fP - True, release the argument handles that were assigned to the parer add argument calls False, Do not release the argument handles assigned to the parser 
.RE
.PP

.SS "void releaseParserArg (\fBargHandle\fP arg)"

.PP
Release the parser argument handle\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP - Argument handle to release 
.RE
.PP

.SS "void setEpilog (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP epilog)"

.PP
Set the Epilog text\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIepilog\fP - Text to display at the end of the help block 
.RE
.PP

.SS "void setKeyPrefix (\fBcmdLineParserHandle\fP parser, \fBparsercstr\fP prefix)"

.PP
Set the argument key prefix value\&. The argument key prefix is the character or string the identifies an input argument key string\&. Any input argument that does not begin with this character is assumed to be a positional argument value\&.
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIprefix\fP - argument prefix value 
.RE
.PP

.SS "void setPositionalNameStop (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP positionalArgumentName)"

.PP
Set the name of the positional argument to stop parsing\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIpositionalArgumentName\fP - Positional name to find 
.RE
.PP

.SS "void setProgramName (\fBcmdLineParserHandle\fP parser, const \fBparsercstr\fP progName)"

.PP
Set the Program Name for the usage string\&. 
.PP
\fBParameters\fP
.RS 4
\fIparser\fP - Handle value returned by \fBgetParser()\fP 
.br
\fIprogName\fP - Program name to use in the usage string 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for argparse from the source code\&.
